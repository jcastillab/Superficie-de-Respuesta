col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 200
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot3d(pngs[i], top = TRUE, width = 1920, height = 1080)
}
# ============================================
# GIF superficie 3D (rgl + gifski) - versión final
# ============================================
pkgs <- c("rgl","gifski","png","rsm")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))
# Crear grilla de valores
grid <- expand.grid(
Temperatura = seq(min(df$Temperatura), max(df$Temperatura), length=40),
Tiempo = seq(min(df$Tiempo), max(df$Tiempo), length=40)
)
grid$z <- predict(m_rsm, newdata=grid)
# Convertir a matriz
zmat <- matrix(grid$z, 40, 40)
# Crear vector de colores según z
ncols <- 100
pal <- colorRampPalette(c("blue", "green", "yellow", "red"))(ncols)
z_scaled <- round( (zmat - min(zmat)) / (max(zmat) - min(zmat)) * (ncols-1) ) + 1
zmat_col <- matrix(pal[z_scaled], 40, 40)
# Graficar superficie 3D con colores según respuesta
open3d(windowRect = c(100, 100, 2020, 1180))
persp3d(
x = seq(min(df$Temperatura), max(df$Temperatura), length=40),
y = seq(min(df$Tiempo), max(df$Tiempo), length=40),
z = zmat,
color = zmat_col,
alpha = 0.8,
xlab = "Temperatura",
ylab = "Tiempo",
zlab = "Respuesta"
)
# Agregar puntos mínimo y máximo como antes
z_min <- predict(m_rsm, newdata=as.data.frame(t(st_point)))
points3d(st_point[1], st_point[2], z_min, col="red", size=10)
text3d(st_point[1], st_point[2], z_min,
texts=paste0("Min: (Temperatura=", round(st_point[1],2),
", Tiempoo=", round(st_point[2],2),
", Resp=", round(z_min,2), ")"),
adj=c(0,1), col="black")
max_idx <- which.max(grid$z)
max_point <- grid[max_idx, ]
points3d(max_point$Temperatura, max_point$Tiempo, max_point$z, col="blue", size=10)
text3d(max_point$Temperatura, max_point$Tiempo, max_point$z,
texts=paste0("Max: (Temperatura=", round(max_point$Temperatura,2),
", Tiempo=", round(max_point$Tiempo,2),
", Resp=", round(max_point$z,2), ")"),
adj=c(1,0), col="blue")
library(rgl)
# Coordenadas de la grilla
x_seq <- seq(min(df$Temperatura), max(df$Temperatura), length=40)
y_seq <- seq(min(df$Tiempo), max(df$Tiempo), length=40)
# Líneas a lo largo del eje X
for(i in 1:length(y_seq)) {
lines3d(x = x_seq,
y = rep(y_seq[i], length(x_seq)),
z = zmat[, i],
col = "black", alpha = 0.3)
}
# Líneas a lo largo del eje Y
for(i in 1:length(x_seq)) {
lines3d(x = rep(x_seq[i], length(y_seq)),
y = y_seq,
z = zmat[i, ],
col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 200
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot3d(pngs[i], top = TRUE)
}
# ============================================
# GIF superficie 3D (rgl + gifski) - versión final
# ============================================
pkgs <- c("rgl","gifski","png","rsm")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))
# Crear grilla de valores
grid <- expand.grid(
Temperatura = seq(min(df$Temperatura), max(df$Temperatura), length=40),
Tiempo = seq(min(df$Tiempo), max(df$Tiempo), length=40)
)
grid$z <- predict(m_rsm, newdata=grid)
# Convertir a matriz
zmat <- matrix(grid$z, 40, 40)
# Crear vector de colores según z
ncols <- 100
pal <- colorRampPalette(c("blue", "green", "yellow", "red"))(ncols)
z_scaled <- round( (zmat - min(zmat)) / (max(zmat) - min(zmat)) * (ncols-1) ) + 1
zmat_col <- matrix(pal[z_scaled], 40, 40)
# Graficar superficie 3D con colores según respuesta
open3d(windowRect = c(100, 100, 2020, 1180))
persp3d(
x = seq(min(df$Temperatura), max(df$Temperatura), length=40),
y = seq(min(df$Tiempo), max(df$Tiempo), length=40),
z = zmat,
color = zmat_col,
alpha = 0.8,
xlab = "Temperatura",
ylab = "Tiempo",
zlab = "Respuesta"
)
# Agregar puntos mínimo y máximo como antes
z_min <- predict(m_rsm, newdata=as.data.frame(t(st_point)))
points3d(st_point[1], st_point[2], z_min, col="red", size=10)
text3d(st_point[1], st_point[2], z_min,
texts=paste0("Min: (Temperatura=", round(st_point[1],2),
", Tiempoo=", round(st_point[2],2),
", Resp=", round(z_min,2), ")"),
adj=c(0,1), col="black")
max_idx <- which.max(grid$z)
max_point <- grid[max_idx, ]
points3d(max_point$Temperatura, max_point$Tiempo, max_point$z, col="blue", size=10)
text3d(max_point$Temperatura, max_point$Tiempo, max_point$z,
texts=paste0("Max: (Temperatura=", round(max_point$Temperatura,2),
", Tiempo=", round(max_point$Tiempo,2),
", Resp=", round(max_point$z,2), ")"),
adj=c(1,0), col="blue")
library(rgl)
# Coordenadas de la grilla
x_seq <- seq(min(df$Temperatura), max(df$Temperatura), length=40)
y_seq <- seq(min(df$Tiempo), max(df$Tiempo), length=40)
# Líneas a lo largo del eje X
for(i in 1:length(y_seq)) {
lines3d(x = x_seq,
y = rep(y_seq[i], length(x_seq)),
z = zmat[, i],
col = "black", alpha = 0.3)
}
# Líneas a lo largo del eje Y
for(i in 1:length(x_seq)) {
lines3d(x = rep(x_seq[i], length(y_seq)),
y = y_seq,
z = zmat[i, ],
col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 200
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot(pngs[i])
}
gifski(pngs, gif_file = "outputs/superficie_3d.gif", delay = 1/90,width = 1920,height = 1080,loop = T)
# ============================================
# GIF superficie 3D (rgl + gifski) - versión final
# ============================================
pkgs <- c("rgl","gifski","png","rsm")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))
# Crear grilla de valores
grid <- expand.grid(
Temperatura = seq(min(df$Temperatura), max(df$Temperatura), length=40),
Tiempo = seq(min(df$Tiempo), max(df$Tiempo), length=40)
)
grid$z <- predict(m_rsm, newdata=grid)
# Convertir a matriz
zmat <- matrix(grid$z, 40, 40)
# Crear vector de colores según z
ncols <- 100
pal <- colorRampPalette(c("blue", "green", "yellow", "red"))(ncols)
z_scaled <- round( (zmat - min(zmat)) / (max(zmat) - min(zmat)) * (ncols-1) ) + 1
zmat_col <- matrix(pal[z_scaled], 40, 40)
# Graficar superficie 3D con colores según respuesta
open3d(windowRect = c(100, 100, 2020, 1180))
persp3d(
x = seq(min(df$Temperatura), max(df$Temperatura), length=40),
y = seq(min(df$Tiempo), max(df$Tiempo), length=40),
z = zmat,
color = zmat_col,
alpha = 0.8,
xlab = "Temperatura",
ylab = "Tiempo",
zlab = "Respuesta"
)
# Agregar puntos mínimo y máximo como antes
z_min <- predict(m_rsm, newdata=as.data.frame(t(st_point)))
points3d(st_point[1], st_point[2], z_min, col="red", size=10)
text3d(st_point[1], st_point[2], z_min,
texts=paste0("Min: (Temperatura=", round(st_point[1],2),
", Tiempoo=", round(st_point[2],2),
", Resp=", round(z_min,2), ")"),
adj=c(0,1), col="black")
max_idx <- which.max(grid$z)
max_point <- grid[max_idx, ]
points3d(max_point$Temperatura, max_point$Tiempo, max_point$z, col="blue", size=10)
text3d(max_point$Temperatura, max_point$Tiempo, max_point$z,
texts=paste0("Max: (Temperatura=", round(max_point$Temperatura,2),
", Tiempo=", round(max_point$Tiempo,2),
", Resp=", round(max_point$z,2), ")"),
adj=c(1,0), col="blue")
library(rgl)
# Coordenadas de la grilla
x_seq <- seq(min(df$Temperatura), max(df$Temperatura), length=40)
y_seq <- seq(min(df$Tiempo), max(df$Tiempo), length=40)
# Líneas a lo largo del eje X
for(i in 1:length(y_seq)) {
lines3d(x = x_seq,
y = rep(y_seq[i], length(x_seq)),
z = zmat[, i],
col = "black", alpha = 0.3)
}
# Líneas a lo largo del eje Y
for(i in 1:length(x_seq)) {
lines3d(x = rep(x_seq[i], length(y_seq)),
y = y_seq,
z = zmat[i, ],
col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 30
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot(pngs[i])
}
gifski(pngs, gif_file = "outputs/superficie_3d.gif", delay = 1/90,width = 1920,height = 1080,loop = T)
file.remove(pngs)
close3d()
# ============================================
# GIF superficie 3D (rgl + gifski) - versión final
# ============================================
pkgs <- c("rgl","gifski","png","rsm")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))
# Crear grilla de valores
grid <- expand.grid(
Temperatura = seq(min(df$Temperatura), max(df$Temperatura), length=40),
Tiempo = seq(min(df$Tiempo), max(df$Tiempo), length=40)
)
grid$z <- predict(m_rsm, newdata=grid)
# Convertir a matriz
zmat <- matrix(grid$z, 40, 40)
# Crear vector de colores según z
ncols <- 100
pal <- colorRampPalette(c("blue", "green", "yellow", "red"))(ncols)
z_scaled <- round( (zmat - min(zmat)) / (max(zmat) - min(zmat)) * (ncols-1) ) + 1
zmat_col <- matrix(pal[z_scaled], 40, 40)
# Graficar superficie 3D con colores según respuesta
open3d(windowRect = c(100, 100, 2020, 1180))
persp3d(
x = seq(min(df$Temperatura), max(df$Temperatura), length=40),
y = seq(min(df$Tiempo), max(df$Tiempo), length=40),
z = zmat,
color = zmat_col,
alpha = 0.8,
xlab = "Temperatura",
ylab = "Tiempo",
zlab = "Respuesta"
)
# Agregar puntos mínimo y máximo como antes
z_min <- predict(m_rsm, newdata=as.data.frame(t(st_point)))
points3d(st_point[1], st_point[2], z_min, col="red", size=10)
text3d(st_point[1], st_point[2], z_min,
texts=paste0("Min: (Temperatura=", round(st_point[1],2),
", Tiempoo=", round(st_point[2],2),
", Resp=", round(z_min,2), ")"),
adj=c(0,1), col="black")
max_idx <- which.max(grid$z)
max_point <- grid[max_idx, ]
points3d(max_point$Temperatura, max_point$Tiempo, max_point$z, col="blue", size=10)
text3d(max_point$Temperatura, max_point$Tiempo, max_point$z,
texts=paste0("Max: (Temperatura=", round(max_point$Temperatura,2),
", Tiempo=", round(max_point$Tiempo,2),
", Resp=", round(max_point$z,2), ")"),
adj=c(1,0), col="blue")
library(rgl)
# Coordenadas de la grilla
x_seq <- seq(min(df$Temperatura), max(df$Temperatura), length=40)
y_seq <- seq(min(df$Tiempo), max(df$Tiempo), length=40)
# Líneas a lo largo del eje X
for(i in 1:length(y_seq)) {
lines3d(x = x_seq,
y = rep(y_seq[i], length(x_seq)),
z = zmat[, i],
col = "black", alpha = 0.3)
}
# Líneas a lo largo del eje Y
for(i in 1:length(x_seq)) {
lines3d(x = rep(x_seq[i], length(y_seq)),
y = y_seq,
z = zmat[i, ],
col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 300
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot(pngs[i])
}
gifski(pngs, gif_file = "outputs/superficie_3d.gif", delay = 1/90,width = 1920,height = 1080,loop = T)
# ============================================
# GIF superficie 3D (rgl + gifski) - versión final
# ============================================
pkgs <- c("rgl","gifski","png","rsm")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))
# Crear grilla de valores
grid <- expand.grid(
Temperatura = seq(min(df$Temperatura), max(df$Temperatura), length=40),
Tiempo = seq(min(df$Tiempo), max(df$Tiempo), length=40)
)
grid$z <- predict(m_rsm, newdata=grid)
# Convertir a matriz
zmat <- matrix(grid$z, 40, 40)
# Crear vector de colores según z
ncols <- 100
pal <- colorRampPalette(c("blue", "green", "yellow", "red"))(ncols)
z_scaled <- round( (zmat - min(zmat)) / (max(zmat) - min(zmat)) * (ncols-1) ) + 1
zmat_col <- matrix(pal[z_scaled], 40, 40)
# Graficar superficie 3D con colores según respuesta
open3d(windowRect = c(100, 100, 2020, 1180))
persp3d(
x = seq(min(df$Temperatura), max(df$Temperatura), length=40),
y = seq(min(df$Tiempo), max(df$Tiempo), length=40),
z = zmat,
color = zmat_col,
alpha = 0.8,
xlab = "Temperatura",
ylab = "Tiempo",
zlab = "Respuesta"
)
# Agregar puntos mínimo y máximo como antes
z_min <- predict(m_rsm, newdata=as.data.frame(t(st_point)))
points3d(st_point[1], st_point[2], z_min, col="red", size=10)
text3d(st_point[1], st_point[2], z_min,
texts=paste0("Min: (Temperatura=", round(st_point[1],2),
", Tiempoo=", round(st_point[2],2),
", Resp=", round(z_min,2), ")"),
adj=c(0,1), col="black")
max_idx <- which.max(grid$z)
max_point <- grid[max_idx, ]
points3d(max_point$Temperatura, max_point$Tiempo, max_point$z, col="blue", size=10)
text3d(max_point$Temperatura, max_point$Tiempo, max_point$z,
texts=paste0("Max: (Temperatura=", round(max_point$Temperatura,2),
", Tiempo=", round(max_point$Tiempo,2),
", Resp=", round(max_point$z,2), ")"),
adj=c(1,0), col="blue")
library(rgl)
# Coordenadas de la grilla
x_seq <- seq(min(df$Temperatura), max(df$Temperatura), length=40)
y_seq <- seq(min(df$Tiempo), max(df$Tiempo), length=40)
# Líneas a lo largo del eje X
for(i in 1:length(y_seq)) {
lines3d(x = x_seq,
y = rep(y_seq[i], length(x_seq)),
z = zmat[, i],
col = "black", alpha = 0.3)
}
# Líneas a lo largo del eje Y
for(i in 1:length(x_seq)) {
lines3d(x = rep(x_seq[i], length(y_seq)),
y = y_seq,
z = zmat[i, ],
col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 300
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot(pngs[i])
}
gifski(pngs, gif_file = "outputs/superficie_3d.gif", delay = 1/90,width = 1920,height = 1080,loop = T)
file.remove(pngs)
# ============================================
# GIF superficie 3D (rgl + gifski) - versión final
# ============================================
pkgs <- c("rgl","gifski","png","rsm")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))
# Crear grilla de valores
grid <- expand.grid(
Temperatura = seq(min(df$Temperatura), max(df$Temperatura), length=40),
Tiempo = seq(min(df$Tiempo), max(df$Tiempo), length=40)
)
grid$z <- predict(m_rsm, newdata=grid)
# Convertir a matriz
zmat <- matrix(grid$z, 40, 40)
# Crear vector de colores según z
ncols <- 100
pal <- colorRampPalette(c("blue", "green", "yellow", "red"))(ncols)
z_scaled <- round( (zmat - min(zmat)) / (max(zmat) - min(zmat)) * (ncols-1) ) + 1
zmat_col <- matrix(pal[z_scaled], 40, 40)
# Graficar superficie 3D con colores según respuesta
open3d(windowRect = c(100, 100, 2020, 1180))
persp3d(
x = seq(min(df$Temperatura), max(df$Temperatura), length=40),
y = seq(min(df$Tiempo), max(df$Tiempo), length=40),
z = zmat,
color = zmat_col,
alpha = 0.8,
xlab = "Temperatura",
ylab = "Tiempo",
zlab = "Respuesta"
)
# Agregar puntos mínimo y máximo como antes
z_min <- predict(m_rsm, newdata=as.data.frame(t(st_point)))
points3d(st_point[1], st_point[2], z_min, col="red", size=10)
text3d(st_point[1], st_point[2], z_min,
texts=paste0("Min: (Temperatura=", round(st_point[1],2),
", Tiempo=", round(st_point[2],2),
", Resp=", round(z_min,2), ")"),
adj=c(0,1), col="black")
max_idx <- which.max(grid$z)
max_point <- grid[max_idx, ]
points3d(max_point$Temperatura, max_point$Tiempo, max_point$z, col="blue", size=10)
text3d(max_point$Temperatura, max_point$Tiempo, max_point$z,
texts=paste0("Max: (Temperatura=", round(max_point$Temperatura,2),
", Tiempo=", round(max_point$Tiempo,2),
", Resp=", round(max_point$z,2), ")"),
adj=c(1,0), col="blue")
library(rgl)
# Coordenadas de la grilla
x_seq <- seq(min(df$Temperatura), max(df$Temperatura), length=40)
y_seq <- seq(min(df$Tiempo), max(df$Tiempo), length=40)
# Líneas a lo largo del eje X
for(i in 1:length(y_seq)) {
lines3d(x = x_seq,
y = rep(y_seq[i], length(x_seq)),
z = zmat[, i],
col = "black", alpha = 0.3)
}
# Líneas a lo largo del eje Y
for(i in 1:length(x_seq)) {
lines3d(x = rep(x_seq[i], length(y_seq)),
y = y_seq,
z = zmat[i, ],
col = "black", alpha = 0.3)
}
# --- 4) Fijar orientación y ejes (para que no “gire raro”) ---
aspect3d(1, 1, 0.7)
base <- par3d("userMatrix")
# --- 5) GIF: rota SOLO theta, mantiene phi/zoom/fov constantes ---
if(!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
nframes  <- 300
pngs     <- sprintf("frame_%03d.png", 1:nframes)
# vista base (phi/zoom/fov fijos)
view3d(theta = 0, phi = 30, zoom = 0.85, fov = 0)
for(i in 1:nframes){
ang <- 2*pi*i/nframes
M   <- base %*% rotationMatrix(ang, 0, 0, 1)  # gira sobre z (Respuesta)
par3d(userMatrix = M)
rgl.snapshot(pngs[i])
}
gifski(pngs, gif_file = "outputs/superficie_3d.gif", delay = 1/90,width = 1920,height = 1080,loop = T)
file.remove(pngs)
